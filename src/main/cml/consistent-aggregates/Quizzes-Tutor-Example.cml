/* Example Context Map for Quizzes Tutor Example */
ContextMap QuizzesTutor {
	contains TournamentContext, CourseExecutionContext, QuizContext, TopicContext

	TournamentContext [D]<-[U] CourseExecutionContext

	TournamentContext [D]<-[U] TopicContext

	TournamentContext [D]<-[U] QuizContext
}

BoundedContext TournamentContext  {
	AntiCorruptionMapping CourseExecution mapping CourseExecutionContext::CourseExecutionAggregate {
		String id maps CourseExecution.id 
		String status maps CourseExecution.status 
		String acronym maps CourseExecution.acronym
		
		InterInvariant existCourseExecution {
			CourseExecution(id) != null
		}
		
		InterInvariant sameStatus {
			status == CourseExecution(id).status
		}
		
		InterInvariant sameAcronym {
			status == CourseExecution(id).acronym
		}
	}

	AntiCorruptionMapping Topic mapping TopicContext::TopicAggregate { 
		String id maps Topic.id
		String courseId maps Topic.courseId
		String name maps Topic.name
			
		InterInvariant existsTopic {
			Topic(id) != null
		}
		
		InterInvariant sameCourse {
			courseId == Topic(id).courseId	
		} 
		
		InterInvariant sameName {
			name == Topic(id).name
		}	 
	}
	// the mapping which refers to a upstream aggregate
	AntiCorruptionMapping Student mapping CourseExecutionContext::CourseExecutionAggregate {
		// the structural mapping, id corresponds to the CourseExecution.id attribute which is the key of the root entity
		String id maps CourseExecution.id
		// this is is a bit more complex because we want to refer to an entity that is not the aggregate root
		// the structural mapping uses the entity name, which is ok because these name are unique inside de aggregate
		Integer studentId maps Student.id 
		String name maps Student.name 
		String username maps Student.username 
			
		InterInvariant existsCourseExecution { 
			// a data constraint, that should exist an instance of the CourseExecution root entity that has this key value
			CourseExecution(id) != null
		}
		
		InterInvariant existsStudent {  
			// the data constraint does a query on Student using the aggregate root key and the student key	
			Student(id, studentId) != null 
		}
		
		InterInvariant sameName {
			// does the query and check the name
			name == Student(id, studentId).name
		}
		
		InterInvariant sameUsername {
			username == Student(id, studentId).username	
		} 
	}
	
	AntiCorruptionMapping Quiz mapping QuizContext::QuizAggregate {
		String id maps Quiz.id 
		String courseExecutionId maps Quiz.courseExecutionId
		// there is no map but there is inter-invariant 
		Integer numberOfQuestions
		DateTime availableDate maps Quiz.availableDate 
		DateTime conclusionDate maps Quiz.conclusionDate 
			
		InterInvariant existsQuiz {
			// identical to 'String id maps CourseExecution.id such that exists CourseExecution(id)'
			Quiz(id) != null
		}
		
		InterInvariant sameCourseExecution {
			courseExecutionId == Quiz(id).courseExecutionId
		}
		
		InterInvariant sameNumberOfQuestions {
			// this means that a complex expression may be used
			numberOfQuestions == Quiz(id).quizQuestions.count 
		}
		
		InterInvariant sameAvailableDate { 
			// identical to 'String name maps Student.name such that equals Student(studentId).name', but done on the root entity		
			availableDate == Quiz(id).availableDate	
		}
		
		InterInvariant sameConclusionDate {
			conclusionDate == Quiz(id).conclusionDate	
		}
	}
	Aggregate TournamentAggregate {
		Entity Tournament {
			aggregateRoot
			Integer id
			Integer numberOfQuestions
			DateTime startTime
			DateTime endTime 
			- TournamentCourseExecution tournamentCourseExecution 
			- List<TournamentTopic> tournamentTopics
			- TournamentCreator tournamentCreator
			- List<Participant> participants
			- TournamentQuiz tournamentQuiz
		}
		Entity TournamentCourseExecution uses courseExecution from CourseExecution {
			String id = courseExecution.id
			String status = courseExecution.status
			String acronym = courseExecution.acronym
		}
		Entity TournamentTopic uses topic from Topic {
			String id = topic.id
			String courseId = topic.courseId
			String name = topic.name
		}
		Entity Participant uses student from Student {
			// here is enough to say uses an attribute of a mapped entity, but the different attributes should be inter-consistent
			// to make it explicit we define a variable of the mapping
			String id = student.id
			Integer studentId = student.studentId
			String name = student.name
			String username = student.username
			DateTime enrollTime
		}
		Entity TournamentCreator uses student from Student {
			String id = student.id
			Integer studentId = student.studentId
			String name = student.name
			String username = student.username
		}
		Entity TournamentQuiz uses quiz from Quiz { 
			String id = quiz.id
			String courseExecutionId = quiz.courseExecutionId
			Integer numberOfQuestion = quiz.numberOfQuestions
			DateTime availableDate = quiz.availableDate
			DateTime conclusionDate = quiz.conclusionDate
		}
		
		IntraInvariant creatorIsFinal {
			final root.tournamentCreator.id
		}
		
		IntraInvariant courseExecutionIsFinal {
			final root.tournamentCourseExecution.id	
		} 

		IntraInvariant finalAfterStart {
			if (now > root.startTime)
			then (final root.startTime && final root.endTime &&
				final root.numberOfQuestions &&
				final root.tournamentTopics
			)  
		}

		IntraInvariant creatorBelongsCourseExecution {
			root.tournamentCourseExecution.id == root.tournamentCreator.id
		}
		
		IntraInvariant topicsAreOfCourse {
			root.tournamentTopics.allMatch(topic -> topic.courseId == root.tournamentCourseExecution.courseId)
		}

		IntraInvariant startBeforeEnd {
			root.startTime < root.endTime 
		}
		
		IntraInvariant participantsBelongToCourseExecution {
			root.participants.allMatch(participant -> participant.id == root.tournamentCourseExecution.id)
		}

		IntraInvariant studentDoesNotParticipateTwice {
			root.participants.count == root.participants.map(participant -> participant.id).distinct.count 
		}
		
		IntraInvariant participantEnrollBeforeStart {
			root.participants.allMatch(participant -> participant.enrollTime < root.startTime)	
		}
		
		IntraInvariant ifCreateIsParticipantTheyHaveSameInformation {
			root.participants.filter(participant -> participant.studentId == root.tournamentCreator.studentId)
				.allMatch(participant -> participant.name == root.tournamentCreator.name && participant.username == root.tournamentCreator.username)
		}		

		IntraInvariant quizIsOfCourseExecution {
			root.tournamentQuiz.courseExecutionId == root.tournamentCourseExecution.id
		}
	}
}

BoundedContext CourseExecutionContext {
	Aggregate CourseExecutionAggregate {
		Entity CourseExecution {
			aggregateRoot
			String id key
			String status
			String acronym
			- List<Student> students
		}
		Entity Student {
			Integer id key
			String name
			String username
		}
	}
}

BoundedContext QuizContext {
	Aggregate QuizAggregate {
		Entity Quiz {
			aggregateRoot
			String id key
			String courseExecutionId
			DateTime availableDate
			DateTime conclusionDate
			- List<QuizQuestion> quizQuestions
		}
		Entity QuizQuestion {
			String question
		}
	}
}

BoundedContext TopicContext {
	Aggregate TopicAggregate{
		Entity Topic {
			aggregateRoot
			String id key
			String courseId
			String name
		}
	}
}

