/* Example Context Map for Quizzes Tutor Example */
ContextMap QuizzesTutor {
	contains TournamentContext, CourseExecutionContext, QuizContext, TopicContext

	TournamentContext [D]<-[U] CourseExecutionContext

	TournamentContext [D]<-[U] TopicContext

	TournamentContext [D]<-[U] QuizContext
}

BoundedContext CourseExecutionContext {
	Aggregate CourseExecutionAggregate {
		Entity CourseExecutionEntity {
			aggregateRoot
			String id key
			String courseId
			String status
			String acronym
			- List<Student> students
			
			Repository CourseExecutionRepository {
				@CourseExecutionEntity findCourseExecutionById(String courseExecutionId);
				@Student findStudentByCourseExecutionIdAndByStudentId(String courseExecutionId, Integer studentId);
			}
		}
		Entity Student { 
			Integer id key
			String name
			String username
		}
		
	}
}

BoundedContext QuizContext {
	Aggregate QuizAggregate {
		Entity QuizEntity {
			aggregateRoot
			String id key
			String courseExecutionId
			DateTime availableDate
			DateTime conclusionDate
			- List<QuizQuestion> quizQuestions
			
			Repository QuizRepository {
				@QuizEntity findQuizById(String id);
			}
		}
		Entity QuizQuestion {
			String question
		}
	}
}

BoundedContext TopicContext {
	Aggregate TopicAggregate{
		Entity TopicEntity {
			aggregateRoot
			String id key
			String courseId
			String name
			
			Repository TopicRepository {
				@TopicEntity findTopicById(String id);
			}
		}
	}
}

BoundedContext TournamentContext  {
	AntiCorruptionTranslation CourseExecution mapping CourseExecutionContext::CourseExecutionAggregate { 
		String id maps CourseExecutionEntity.id 
		String courseId maps CourseExecutionEntity.courseId
		String status maps CourseExecutionEntity.status 
		String acronym maps CourseExecutionEntity.acronym 
		
		Invariant existsCourseExecution {
			findCourseExecutionById(id) != null 
		}
		
		Invariant sameCourseId {
			courseId == findCourseExecutionById(id).courseId
		}
		
		Invariant sameStatus {
			status == findCourseExecutionById(id).status
		}
		
		Invariant sameAcronym {
			acronym == findCourseExecutionById(id).acronym
		}
	}

	AntiCorruptionTranslation Topic mapping TopicContext::TopicAggregate { 
		String id maps TopicEntity.id
		String courseId maps TopicEntity.courseId
		String name maps TopicEntity.name
			
		Invariant existsTopic {
			findTopicById(id) != null
		}
		
		Invariant sameCourse {
			courseId == findTopicById(id).courseId	
		} 
		
		Invariant sameName {
			name == findTopicById(id).name
		}	 
	}
	// the mapping which refers to a upstream aggregate
	AntiCorruptionTranslation Student mapping CourseExecutionContext::CourseExecutionAggregate {
		// the structural mapping, id corresponds to the CourseExecutionEntity.id attribute which is the key of the root entity
		String id maps CourseExecutionEntity.id
		// this is is a bit more complex because we want to refer to an entity that is not the aggregate root
		// the structural mapping uses the entity name, which is ok because these name are unique inside the aggregate
		Integer studentId maps Student.id 
		String name maps Student.name 
		String username maps Student.username 
			
		Invariant existsCourseExecution { 
			// a data constraint, that should exist an instance of the CourseExecutionEntity root entity that has this key value
			// it uses a query that is defined in the aggregate repository
			findCourseExecutionById(id) != null
		}
		
		Invariant existsStudent {  
			// the data constraint does a query on Student using the aggregate root key and the student key	
			// the query is defined in aggregate repository
			findStudentByCourseExecutionIdAndByStudentId(id, studentId) != null 
		}
		
		Invariant sameName {
			// does the query and check the name
			name == findStudentByCourseExecutionIdAndByStudentId(id, studentId).name
		}
		
		Invariant sameUsername {
			username == findStudentByCourseExecutionIdAndByStudentId(id, studentId).username	
		} 
	}
	
	AntiCorruptionTranslation Quiz mapping QuizContext::QuizAggregate {
		String id maps QuizEntity.id 
		String courseExecutionId maps QuizEntity.courseExecutionId
		// there is no map but there is inter-invariant that works as a calculated attribute
		Integer numberOfQuestions
		DateTime availableDate maps QuizEntity.availableDate
		DateTime conclusionDate maps QuizEntity.conclusionDate 
			
		Invariant existsQuiz {
			findQuizById(id) != null
		}
		
		Invariant sameCourseExecution {
			courseExecutionId == findQuizById(id).courseExecutionId
		}
		
		Invariant sameNumberOfQuestions {
			// this means that a complex expression may be used
			numberOfQuestions == findQuizById(id).quizQuestions.count()
		}
		
		Invariant sameAvailableDate { 
			availableDate == findQuizById(id).availableDate	
		}
		
		Invariant sameConclusionDate {
			conclusionDate == findQuizById(id).conclusionDate	
		}
	}
	Aggregate TournamentAggregate {
		Entity Tournament {
			aggregateRoot
			Integer id
			Integer numberOfQuestions
			DateTime startTime
			DateTime endTime 
			- TournamentCourseExecution tournamentCourseExecution 
			- List<TournamentTopic> tournamentTopics
			- TournamentCreator tournamentCreator
			- List<Participant> participants
			- TournamentQuiz tournamentQuiz
			// meaningless from the domain perspective, but added to test complex expressions
			- List<Answer> answers
		}
		// meaningless from the domain perspective, but added to test complex expressions
		Entity Answer {
			String id
			- List<Option> options
		}
		// meaningless from the domain perspective, but added to test complex expressions
		Entity Option {
			String value
		}
		Entity TournamentCourseExecution uses courseExecution from CourseExecution {
			// here is enough to say uses an attribute of a mapped entity, but the different attributes should be inter-consistent
			// to make it explicit we define a variable, courseExecution, of the translation mapping. CourseExecution 
			String id = courseExecution.id
			String courseId = courseExecution.courseId
			String status = courseExecution.status
			String acronym = courseExecution.acronym
		}
		Entity TournamentTopic uses topic from Topic {
			String id = topic.id
			String courseId = topic.courseId
			String name = topic.name
		}
		Entity Participant uses student from Student {
			String id = student.id
			Integer studentId = student.studentId
			String name = student.name
			String username = student.username
			DateTime enrollTime
		}
		Entity TournamentCreator uses student from Student {
			String id = student.id
			Integer studentId = student.studentId
			String name = student.name
			String username = student.username
		}
		Entity TournamentQuiz uses quiz from Quiz { 
			String id = quiz.id
			String courseExecutionId = quiz.courseExecutionId 
			Integer numberOfQuestion = quiz.numberOfQuestions
			DateTime availableDate = quiz.availableDate
			DateTime conclusionDate = quiz.conclusionDate
		}
		
		Invariant courseExecutionIsFinal {
			// the tournament cannot change course execution
			final root.tournamentCourseExecution.id
		}
		
		Invariant creatorIsFinal {
			// the tournament creator cannot change
			final root.tournamentCreator.id
		}

		Invariant finalAfterStart {
			// after the tournament starts the it is not possible to change these attributes
			if (now > root.startTime) 
			then (final root.startTime 
				root.endTime
				root.participants
				root.numberOfQuestions 
				root.tournamentTopics
			) 
		}

		Invariant creatorBelongsCourseExecution {
			// the tournament creator should be enrolled in the tournament course execution
			root.tournamentCourseExecution.id == root.tournamentCreator.id
		}
		
		Invariant topicsAreOfCourse {
			// all tournament topics are of same course execution course 
			root.tournamentTopics.allMatch(topic -> topic.courseId == root.tournamentCourseExecution.courseId)
		} 

		Invariant startBeforeEnd {
			// tournament start time before end time
			root.startTime < root.endTime
		}
		
		Invariant participantsBelongToCourseExecution {
			// all participants are enrolled in the tournament course execution
			root.participants.allMatch(participant -> participant.id == root.tournamentCourseExecution.id) 
		}

		Invariant studentDoesNotParticipateTwice {
			// a participant is not registered twice
			root.participants.count() == root.participants.map(participant -> participant.id).distinct().count()
		}
		
		Invariant participantEnrollBeforeStart {
			// participants cannot enroll after tournament start
			root.participants.allMatch(participant -> participant.enrollTime < root.startTime)	
		}
		
		Invariant whenCreatorAlsoIsParticipantTheyHaveSameInformation {
			// if tournament creator is also participant, the their information should be consistent
			root.participants.filter(participant -> participant.studentId == root.tournamentCreator.studentId)
				.allMatch(participant -> participant.name == root.tournamentCreator.name && participant.username == root.tournamentCreator.username)
		}		

		Invariant quizIsOfCourseExecution {
			// tournament quiz is of course execution
			root.tournamentQuiz.courseExecutionId == root.tournamentCourseExecution.id
		}
		
		// begin of complexExpressionN are domain problem meaningless but
		// interesting to exercise the expression language
		Invariant complexExpression7 {
			// given the root entity attribute answers generate a collection of the options of each answer
			root.answers.flatMap(answer -> answer.options)
				// given the collection of options generate the collection of values
				.map(option -> option.value)
				// find first
				.findFirst()
				// compare with string
				.get() == "dummy"
		}
		
		Invariant complexExpression6 {
			// given the root entity attribute answers
			root.answers
				// generate a collection of the options of each answer
				.flatMap(answer -> answer.options)
				// find any
				.findAny()
				// check if there is a result
				.isEmpty()
		}
		
		Invariant complexExpression5 {
			root.answers.map(answer -> answer.options)
				// all options collections must have 6 elements
				.allMatch(options -> options.count() == 6 && true)
		}
		
		Invariant complexExpression4 {
			root.answers.map(answer -> answer.options)
				// obtain the options collections where the number of elements with value "dummy" is 5
				.filter(options -> options.filter(option -> option.value == "dummy").count() == 5)
				// there should be 5 of such options collections
				.count() == 5 
		}
		
		Invariant complexExpression3 {
			root.answers
				// generate a list o booleans where the element is true if each answer has 5 options and false otherwise 
				.map(answer -> answer.options.count() == 5)
				// the collection of booleans should have 5 elements
				.count() == 5
		} 
		
		Invariant complexExpression2 {
			root.answers
				.flatMap(answer -> answer.options)
				.filter(option -> option.value == "dummy")
				.count() == 0
		}		
		
		Invariant complexExpression1 {
			root.answers
				.map(answer -> answer.options)
				.map(options -> options.count())
				.count() == 5
		}
		// end of complexExpressionN 
	}
}

