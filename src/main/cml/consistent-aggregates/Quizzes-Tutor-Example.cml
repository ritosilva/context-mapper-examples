/* Example Context Map for Quizzes Tutor Example */
ContextMap QuizzesTutor {
	contains TournamentContext, CourseExecutionContext, QuizContext, TopicContext

	TournamentContext [D]<-[U] CourseExecutionContext

	TournamentContext [D]<-[U] TopicContext

	TournamentContext [D]<-[U] QuizContext
}

BoundedContext CourseExecutionContext {
	Aggregate CourseExecutionAggregate {
		Entity CourseExecutionEntity {
			aggregateRoot
			String id key
			String courseId
			String status
			String acronym
			- List<Student> students
			
			Repository CourseExecutionRepository {
				@CourseExecutionEntity findCourseExecutionById(String courseExecutionId);
				@Student findStudentByCourseExecutionIdAndByStudentId(String courseExecutionId, Integer studentId);
			}
		}
		Entity Student { 
			Integer id key
			String name
			String username
		}
		
	}
}

BoundedContext QuizContext {
	Aggregate QuizAggregate {
		Entity QuizEntity {
			aggregateRoot
			String id key
			String courseExecutionId
			DateTime availableDate
			DateTime conclusionDate
			- List<QuizQuestion> quizQuestions
			
			Repository QuizRepository {
				@QuizEntity findQuizById(String id);
			}
		}
		Entity QuizQuestion {
			String question
		}
	}
}

BoundedContext TopicContext {
	Aggregate TopicAggregate{
		Entity TopicEntity {
			aggregateRoot
			String id key
			String courseId
			String name
			
			Repository TopicRepository {
				@TopicEntity findTopicById(String id);
			}
		}
	}
}

BoundedContext TournamentContext  {
	AntiCorruptionTranslation CourseExecution mapping CourseExecutionContext::CourseExecutionAggregate { 
		String id maps CourseExecutionEntity.id 
		String courseId maps CourseExecutionEntity.courseId
		String status maps CourseExecutionEntity.status 
		String acronym maps CourseExecutionEntity.acronym 
		
		InterAggregateInvariant existsCourseExecution {
			findCourseExecutionById(id) != null 
		}
		
		InterAggregateInvariant sameCourseId {
			courseId == findCourseExecutionById(id).courseId
		}
		
		InterAggregateInvariant sameStatus {
			status == findCourseExecutionById(id).status
		}
		
		InterAggregateInvariant sameAcronym {
			acronym == findCourseExecutionById(id).acronym
		}
	}

	AntiCorruptionTranslation Topic mapping TopicContext::TopicAggregate { 
		String id maps TopicEntity.id
		String courseId maps TopicEntity.courseId
		String name maps TopicEntity.name
			
		InterAggregateInvariant existsTopic {
			findTopicById(id) != null
		}
		
		InterAggregateInvariant sameCourse {
			courseId == findTopicById(id).courseId	
		} 
		
		InterAggregateInvariant sameName {
			name == findTopicById(id).name
		}	 
	}
	// the mapping which refers to a upstream aggregate
	AntiCorruptionTranslation Student mapping CourseExecutionContext::CourseExecutionAggregate {
		// the structural mapping, id corresponds to the CourseExecution.id attribute which is the key of the root entity
		String id maps CourseExecutionEntity.id
		// this is is a bit more complex because we want to refer to an entity that is not the aggregate root
		// the structural mapping uses the entity name, which is ok because these name are unique inside de aggregate
		Integer studentId maps Student.id 
		String name maps Student.name 
		String username maps Student.username 
			
		InterAggregateInvariant existsCourseExecution { 
			// a data constraint, that should exist an instance of the CourseExecution root entity that has this key value
			findCourseExecutionById(id) != null
		}
		
		InterAggregateInvariant existsStudent {  
			// the data constraint does a query on Student using the aggregate root key and the student key	
			findStudentByCourseExecutionIdAndByStudentId(id, studentId) != null 
		}
		
		InterAggregateInvariant sameName {
			// does the query and check the name
			name == findStudentByCourseExecutionIdAndByStudentId(id, studentId).name
		}
		
		InterAggregateInvariant sameUsername {
			username == findStudentByCourseExecutionIdAndByStudentId(id, studentId).username	
		} 
	}
	
	AntiCorruptionTranslation Quiz mapping QuizContext::QuizAggregate {
		String id maps QuizEntity.id 
		String courseExecutionId maps QuizEntity.courseExecutionId
		// there is no map but there is inter-invariant 
		Integer numberOfQuestions
		DateTime availableDate maps QuizEntity.availableDate
		DateTime conclusionDate maps QuizEntity.conclusionDate 
			
		InterAggregateInvariant existsQuiz {
			// identical to 'String id maps CourseExecution.id such that exists CourseExecution(id)'
			findQuizById(id) != null
		}
		
		InterAggregateInvariant sameCourseExecution {
			courseExecutionId == findQuizById(id).courseExecutionId
		}
		
		InterAggregateInvariant sameNumberOfQuestions {
			// this means that a complex expression may be used
			numberOfQuestions == findQuizById(id).quizQuestions.count()
		}
		
		InterAggregateInvariant sameAvailableDate { 
			// identical to 'String name maps Student.name such that equals Student(studentId).name', but done on the root entity		
			availableDate == findQuizById(id).availableDate	
		}
		
		InterAggregateInvariant sameConclusionDate {
			conclusionDate == findQuizById(id).conclusionDate	
		}
	}
	Aggregate TournamentAggregate {
		Entity Tournament {
			aggregateRoot
			Integer id
			Integer numberOfQuestions
			DateTime startTime
			DateTime endTime 
			- TournamentCourseExecution tournamentCourseExecution 
			- List<TournamentTopic> tournamentTopics
			- TournamentCreator tournamentCreator
			- List<Participant> participants
			- TournamentQuiz tournamentQuiz
			// meaningless but added to test complex expressions
			- List<Answer> answers
		}
		// meaningless but added to test complex expressions
		Entity Answer {
			String id
			- List<Option> options
		}
		// meaningless but added to test complex expressions
		Entity Option {
			String value
		}
		Entity TournamentCourseExecution uses courseExecution from CourseExecution {
			String id = courseExecution.id
			String courseId = courseExecution.courseId
			String status = courseExecution.status
			String acronym = courseExecution.acronym
		}
		Entity TournamentTopic uses topic from Topic {
			String id = topic.id
			String courseId = topic.courseId
			String name = topic.name
		}
		Entity Participant uses student from Student {
			// here is enough to say uses an attribute of a mapped entity, but the different attributes should be inter-consistent
			// to make it explicit we define a variable of the mapping
			String id = student.id
			Integer studentId = student.studentId
			String name = student.name
			String username = student.username
			DateTime enrollTime
		}
		Entity TournamentCreator uses student from Student {
			String id = student.id
			Integer studentId = student.studentId
			String name = student.name
			String username = student.username
		}
		Entity TournamentQuiz uses quiz from Quiz { 
			String id = quiz.id
			String courseExecutionId = quiz.courseExecutionId 
			Integer numberOfQuestion = quiz.numberOfQuestions
			DateTime availableDate = quiz.availableDate
			DateTime conclusionDate = quiz.conclusionDate
		}
		
		// complexExpressions N are domain problem meaningless but
		// interesting to exercise the expression language
		IntraAggregateInvariant complexExpression7 {
			root.answers.flatMap(answer -> answer.options)
				.map(option -> option.value)
				.findFirst()
				.get() == "dummy"
		}
		
		IntraAggregateInvariant complexExpression6 {
			root.answers.flatMap(answer -> answer.options).findAny().isEmpty()
		}
		
		IntraAggregateInvariant complexExpression5 {
			root.answers.map(answer -> answer.options)
				.allMatch(options -> options.count() == 6 && true)
		}
		
		IntraAggregateInvariant complexExpression4 {
			root.answers.map(answer -> answer.options)
				.filter(options -> options.filter(option -> option.value == "dummy").count() == 5).count() == 5 
		}
		
		IntraAggregateInvariant complexExpression3 {
			root.answers.map(answer -> answer.options.count() == 5).count() == 5
		} 
		
		IntraAggregateInvariant complexExpression2 {
			root.answers.flatMap(answer -> answer.options).filter(option -> option.value == "dummy").count() == 0
		}		
		
		IntraAggregateInvariant complexExpression1 {
			root.answers.map(answer -> answer.options).map(options -> options.count()).count() == 5
		}
		
		IntraAggregateInvariant courseExecutionIsFinal {
			final root.tournamentCourseExecution.id
		}
		
		IntraAggregateInvariant creatorIsFinal {
			final root.tournamentCreator.id
		}

		IntraAggregateInvariant finalAfterStart {
			if (now > root.startTime) 
			then (final root.startTime root.endTime
				root.numberOfQuestions 
				root.tournamentTopics
			) 
		}

		IntraAggregateInvariant creatorBelongsCourseExecution {
			root.tournamentCourseExecution.id == root.tournamentCreator.id
		}
		
		IntraAggregateInvariant topicsAreOfCourse {
			root.tournamentTopics.allMatch(topic -> topic.courseId == root.tournamentCourseExecution.courseId)
		} 

		IntraAggregateInvariant startBeforeEnd {
			root.startTime < root.endTime
		}
		
		IntraAggregateInvariant participantsBelongToCourseExecution {
			root.participants.allMatch(participant -> participant.id == root.tournamentCourseExecution.id) 
		}

		IntraAggregateInvariant studentDoesNotParticipateTwice {
			root.participants.count() == root.participants.map(participant -> participant.id).distinct().count()
		}
		
		IntraAggregateInvariant participantEnrollBeforeStart {
			root.participants.allMatch(participant -> participant.enrollTime < root.startTime)	
		}
		
		IntraAggregateInvariant whenCreatorAlsoIsParticipantTheyHaveSameInformation {
			root.participants.filter(participant -> participant.studentId == root.tournamentCreator.studentId)
				.allMatch(participant -> participant.name == root.tournamentCreator.name && participant.username == root.tournamentCreator.username)
		}		

		IntraAggregateInvariant quizIsOfCourseExecution {
			root.tournamentQuiz.courseExecutionId == root.tournamentCourseExecution.id
		}
	}
}

